[["manipulación-de-datos.html", "Sección 3 Manipulación de datos 3.1 Modificar data 3.2 Combinar data", " Sección 3 Manipulación de datos Continuando con el análisis las siguientes operaciones que debemos hacer es la consolidación y transformación de nuestros datos. Data Wrangling Data transformation 3.1 Modificar data Aquí vamos a ver algunas de las funciones más utilizadas en el análisis de datos. filter: sirve para obtener un subconjunto de tus las filas de acuerdo a las condiciones que determines. select: escoge las columnas de acuerdo con el nombre que selecciones. arrange: reordena de acuerdo con algún criterio (ejemplo:nombre, valor, etc). mutate: sirve para crear nuevas variables (ya lo utilizamos en la sección análisis preliminar). summarise: reduce las variables a un resumen de acuerdo con ciertos criterios. spread o pivot_wider: sirve para cambiar la forma del dataframe que se está usando de largo a ancho. gather o pivot_longer: sirve para cambiar la forma del dataframe utilizado de archo a largo. Todas estas funciones tienen una forma de operar similar, el primer argumento que reciben es un data.frame. Los argumentos que siguen muestran las operaciones a realizar y entregan un data.frame nuevo con estas operaciones ejecutadas. El script source.R en la carpeta data tiene los commandos para importar los datos y las transformaciones básicas que hicimos para que puedan correr el código directo en un script, sin necesidad de hacerlo en el notebook. En primer lugar queremos seleccionar únicamente las variables que vamos a necesitar y no estar cargando con variables, para esto usamos select. Suponiendo que nos interesa el análisis por sexo y no queremos datos que no tengan asignados un sexo podemos usar filter para filtrar los valores distintos a NA. Además, vamos a utilizar el commando mutate para transformar la variable sex a que nos indique si es mujer u hombre, en lugar de 1 y 2. Lo mismo para education_level, en dónde queremos que nos tome los valores como categóricos y no como numéricos. bol_18_tidy &lt;- data_rename_18 %&gt;% select(education_level, sex, age, injured, attacked, attempt_suicide, felt_lonely, worried_sleep, weight) %&gt;% filter(!is.na(sex)) %&gt;% mutate(sex = ifelse(sex==1, &quot;men&quot;, ifelse(sex==2, &quot;women&quot;, sex)), education_level = as.character(education_level), age = case_when(age ==1 ~ &quot;11 or younger&quot;, age ==2 ~ &quot;12 years old&quot;, age ==3 ~ &quot;13 years old&quot;, age ==4 ~ &quot;14 years old&quot;, age ==5 ~ &quot;15 years old&quot;, age ==6 ~ &quot;16 years old&quot;, age ==7 ~ &quot;17 years old&quot;, age ==8 ~ &quot;18 or older&quot;, TRUE ~ NA_character_)) Ejercicio 1 (2 minutos): qué haríamos si quiero encontrar el conjunto de personas que fueran mujeres menores a 13 años? Muchas veces queremos crear indicadores o resúmenes de nuestros datos. Para esto es muy útil el paquete dplyr del Tidyverse. La función group_by nos ayuda a definir la desagregación con la que queremos trabajar y luego realiza las operaciones que definamos utilizando esos grupos. Después de esto utilizaremos la función summarise para resumir nuestros datos en los grupos que definimos. mental_health &lt;- bol_18_tidy %&gt;% group_by(sex) %&gt;% summarise(felt_lonely_pct = sum(weight[felt_lonely&gt;3],na.rm = TRUE) /sum(weight[!is.na(felt_lonely)], na.rm = TRUE), felt_lonely_n = length(na.omit(felt_lonely)), worried_sleep_pct = sum(weight[worried_sleep&gt;3],na.rm = TRUE) /sum(weight[!is.na(worried_sleep)], na.rm = TRUE), worried_sleep_n = length(na.omit(worried_sleep)), attempt_suicide_pct = sum(weight[attempt_suicide&gt;1],na.rm = TRUE) /sum(weight[!is.na(attempt_suicide)], na.rm = TRUE), attempt_suicide_n = length(na.omit(attempt_suicide))) En este caso porque las variables no son 1 o 0, o numéricos, sino distintos valores categóricos no podemos usar las funciones básicas de summarise, pero vamos a hacer un ejemplo para mostrar como se usa. Creamos una variable dummy con el valor de 1 si la persona se ha dormido preocupada siempre o casi siempre, asignamos 0 en otro caso y mantenemos los NA. El promedio debería de ser el mismo que en el caso anterior. mental_health_sum &lt;- bol_18_tidy %&gt;% mutate(worried_sleep_dum = case_when(worried_sleep &gt;3 ~1, worried_sleep &lt;=3 ~ 0, TRUE ~ NA_real_)) %&gt;% group_by(sex) %&gt;% summarise(worried_sleep_pct = mean(worried_sleep_dum, na.rm = TRUE), worried_sleep_pct_w = weighted.mean(worried_sleep_dum, weight, na.rm = TRUE)) Ejercicio 2 (5 minutos): Qué grupo de edad tiene un porcentaje más alto de jóvenes que se duermen siempre o casi siempre preocupados?. Observando los dataframes que hemos creado, podemos ver que este está a lo ancho. Para muchas de las operaciones en R y por cuestiones de limpieza, muchas veces es preferible tener el dataframe a lo largo. Sobre todo si este se va a utilizar para visualizarlo de alguna forma. Para esto las funciones que nos ayudan son gather y pivot_longer. Las dos funciones hacen básicamente lo mismo, pero la segunda es una versión más reciente que fue diseñada para facilitar y generalizar la función gather. Por lo que normalmente se prefiere. Los argumentos que le damos son el dataframe (se lo estamos pasando con el pipe); las columnas en las que queremos aplicar la función, en este caso nuestros 3 indicadores. Y definimos dos nuevas columnas, una donde queremos guardar los indicadores y otra donde queremos guardar los valores. mental_indicators &lt;- mental_health %&gt;% pivot_longer(cols = felt_lonely_pct:attempt_suicide_n, names_to = &#39;indicator&#39;, values_to = &#39;value&#39;) Aquí también podemos usar pivot_wider o spread ya que tenemos los valores y el tamaño de la muestra en la misma columna, y es más fácil ver los valores si los tomamos como dos columnas distintas una que contenga los valores y otra que contenga el tamaño de la muestra. Así que usando una función de manejo de texto vamos a extraer las últimas letras de la función para ver si es n o pct. Pueden encontrar aquí la cheatsheet de String manipulation Después a la función pivot_wider le damos como argumentos: el dataframe y las variables de dónde debe tomar el nuevo nombre y los valores. mental_indicators &lt;- mental_indicators %&gt;% mutate(type = sub(&quot;.*_&quot;, &quot;&quot;, indicator), indicator = case_when(type == &quot;pct&quot; ~ str_sub(indicator, 1,-5L), type == &quot;n&quot; ~ str_sub(indicator, 1,-3L))) %&gt;% pivot_wider(names_from = type, values_from = value) Ejercicio 3 (6 minutos): usando al menos dos funciones de las que hemos aprendido genera la diferencia en los coeficientes de mujeres y hombres para estas 3 variables. mental_indicators_diff &lt;- mental_indicators %&gt;% select(-n) %&gt;% pivot_wider(names_from = sex, values_from = pct) %&gt;% mutate(diff = (men - women)*100, gap_pos = women +(diff/200)) 3.2 Combinar data Otra serie de funciones que es muy utilizada en análisis de datos son las que nos ayudan a combinar datos, aquí veremos únicamente algunas de las más utilizadas. join: sirve para combinar dataframes, puede ser left, right, inner y full. rbind: x &lt;- tibble(name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Stuart&quot;, &quot;Pete&quot;), instrument = c(&quot;guitar&quot;, &quot;bass&quot;, &quot;guitar&quot;, &quot;drums&quot;, &quot;bass&quot;, &quot;drums&quot;)) y &lt;- tibble(name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Brian&quot;), band = c(&quot;TRUE&quot;, &quot;TRUE&quot;, &quot;TRUE&quot;, &quot;TRUE&quot;, &quot;FALSE&quot;)) inner_join(x, y) ## Joining, by = &quot;name&quot; ## # A tibble: 4 x 3 ## name instrument band ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John guitar TRUE ## 2 Paul bass TRUE ## 3 George guitar TRUE ## 4 Ringo drums TRUE left_join(x, y) ## Joining, by = &quot;name&quot; ## # A tibble: 6 x 3 ## name instrument band ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John guitar TRUE ## 2 Paul bass TRUE ## 3 George guitar TRUE ## 4 Ringo drums TRUE ## 5 Stuart bass &lt;NA&gt; ## 6 Pete drums &lt;NA&gt; semi_join(x, y) ## Joining, by = &quot;name&quot; ## # A tibble: 4 x 2 ## name instrument ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 George guitar ## 4 Ringo drums anti_join(x, y) ## Joining, by = &quot;name&quot; ## # A tibble: 2 x 2 ## name instrument ## &lt;chr&gt; &lt;chr&gt; ## 1 Stuart bass ## 2 Pete drums Resumamos lo que observamos arriba: Tipo Acción inner Incluye las filas que aparecen tanto en x como en y left Incluye todas las filas en x y las filas de y que coincidan semi Incluye las filas de x que coincidan con y anti Incluye las filas de x que no coinciden con y Esto lo vamos a utilizar para nuestro ejercicio de visualización. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
